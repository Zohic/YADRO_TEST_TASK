# Оглавление
- [Задание](#Задание)
- [Теория](#Теория)
- [Технические решения](#Технические-решения)
- [API](#API)
- [Примеры работы](#Примеры-работы)
- [Ответ на задание](#Ответ-на-задание)
- [Дополнения после дедлайна](#Дополнения_после_дедлайна)
 ____
 
 # Задание
- Написать на С++ класс быстрого прямого и обратного преобразования Фурье комплексных значений с возможной длиной преобразования кратной 2, 3, 5.
- Запустить для случайных комплексных входных данных сначала прямое, а потом обратное преобразование Фурье.
- Сравнить ошибку между входными и выходными данными.
____
 # Теория
 ## В данном репозитории реализовано
 1. ### Дискретное преобразование Фурье
 2. ### Дискретное преобразование Фурье с разделением на множители
    
   <br/>
   
При разделении преобразование фурье с длиной преобразования $N$ на две части $N = N_1 * N_2$ асимптотическая сложность уменьшается с $O(N^2)$ до $O(N_1N_2)$
 <p align="center"> пример для $N = 1000$ при разбиении $N_1 = 20, N_2 = 50$ </p>
 <p align="center"> $N^2=10e6$ и $20*50=1000$ (разница в три порядка) </p>
 <br/>

 3. ### Дискретное преобразование Фурье с рекурсивным разделением на множители (Вариант алгоритма Кули-Тьюки)<br/>
   Длина преобразования рекурсивно разбивается на подмножители. Каждое разбиние уменьшает количество необходимых инструкций в итоге<br/>
   Каждый вариант имеет прямой и обратный вариант преобразования
   
   ___
# Технические решения
- Реализован класс __FFT__ в пространстве имён __YADRO_TEST__
- Все методы класса статические, вместо реализации шаблона singleton
- В шаблонах я использовал if constexpr, так что для сборки нужен минимум c++17
- В заголовчном файле [config.hpp](./include/config.hpp) устанавливается флаг определяющий точность чисел используемых в проекте (float | double)
- Так как для реализуемых преобразований Фурье необходимы проходы по строкам/столбцам матриц, вместо использования матриц в пространстве имён реализован класс ``matrix_vector_mapper`` позволяющий проходить по линейным массивам как по строкам/столбцам матрицы
- методы класса __FFT__ являются шаблонами принимающими enum ``dft_direction``, который определяет необходимое преобразование (прямое/обратное)
- В во всех методах с разделением на множители используется метод ``dft_mapped`` преобразующий строки/столбцы матрицы. Каждое преобразование строки/столбца выполняется либо ассинхронно, либо параллельно с помощью ``std::async`` и ``std::future`` или пула потоков, что может ускорить работу (``std::async`` не всегда выполняет работу в отдельном потоке)

# USER API
### dft<dft_direction>
```
//Делает простое прямое/обратное дискретное преобразование Фурье
FFT::dft<dft_direction>(const std::vector<complex_t> poinst, std::vector<complex_t>& spectrum)
```
### fft_subdivided<dft_direction>
```
//Делает дискретное преобразование фурье с разбиением на множители один из которых N1  
//Бросит исключение, если длина преобразования не делится на N1
FFT::fft_subdivided<dft_direction>(const std::vector<complex_t> poinst, std::vector<complex_t>& spectrum, size_t N1)
```
### fft_recursive<dft_direction>
```
//Делает рекурсивное разбиение на множители (2, 3, 4, 5, 7, 8, 16, 32)
FFT::fft_recursive<dft_direction>(const std::vector<complex_t> poinst, std::vector<complex_t>& spectrum, size_t N1)
```

# Примеры работы

Задавшись, например, максимальной интересующей нас частотой и шагом спектра по частоте, считаем количество необходимых отсчетов.<br>
Также сгенерируем отсчёты суммы синуса и косинуса частоты которых кратны шагу спектра для наглядности.

```
const number_t fmax = 100;
const number_t fs = fmax * 2;
const number_t Ts = 1.0 / fs;	

const number_t df = 4;
const size_t pts_cnt = std::ceil(1.0 / (df * Ts));
	
const number_t dw = 2 * pi * df;

const number_t f = df * 3;
const number_t w = 2 * pi * f;

for (int i = 0; i < pts_cnt; i++) {
 points[i] = 3.5 * cos_f(w * Ts * i) + 2.1 * sin_f(w * 2 * Ts * i);
}
```

Получим спектр одним из методов. Также нормируем спектр. Запишем отсчёты в файл. Построим графики.

```
using namespace YADRO_TEST;
using dft_dir = FFT::dft_direction;

std::vector<complex_t> points(pts_cnt);
std::vector<complex_t> FFTspectrum(points.size());
1)FFT::dft<dft_dir::forward>(points, FFTspectrum);
2)FFT::fft_subdivided<dft_dir::forward>(points, FFTspectrum, pts_cnt / 5);
3)FFT::fft_recursive<dft_dir::forward>(points, FFTspectrum);
```

Видим отсчёты с заданной амплитудой на заданных частотах симметричные относительно центральной частоты. Фазовый спектр анти-симметричен.

<img style="display:inline; margin-right: 20px" width="50%" height="100%" src="images/amp.png"/><img width="50%" height="100%" style="display:inline" src="images/phas.png"/>

# Ответ на задание
Зададим случайный комплексный сигнал. Произведём над ним прямое и обратное преобразование Фурье. Затем возьмём модуль от разности изначальных и полученных чисел. Возьмём максимальную ошибку для оценки. Смысл имеет говорить об ошибке относительно максимальной амплитуды сигнала.

## Были получены такие значения для точности double для различных методов:

| ошибка | dft error | fft_subdivide error | fft error |
|--------|-----------------------|-------------------------|------------------------|
проценты | 0.00000000007317285847% | 0.00000000000288168841% | 0.00000000000062260506%
децибелы | -202.71 | -230.80 | -244.11 |


## Были получены такие значения для точности float для различных методов:

| ошибка | dft error | fft_subdivide error | fft error |
|--------|-----------------------|-------------------------|------------------------|
проценты | 0.02670340426266193390% | 0.00243441457860171795% | 0.00035030560684390366%
децибелы | -31.46 | -52.27 | -69.11 |

Ошибки незначительные, у float на 8 порядков хуже чем у double.
Код для этой задачи находится в [test_accuracy.cpp](./src/test_accuracy.cpp)

# Дополнения после дедлайна

После дедлайна были добавлены изменения в репозиторий  
## [Версия репозитория в день дедлайна доступна по ссылке](https://github.com/Zohic/YADRO_TEST_TASK/tree/9ceff7c44d50776ed6da2e76bce69d9ac781fae1)

## Что добавлено
- Изменён рекурсивный алгоритм, так что он:
  1) эффективнее делит на множетели 
  2) не делает лишних аллокаций, всего одну
- в класс FFT добавлен подкласс preallocated выполняющий функцию arena/linear allocator для более быстрых аллокаций которым пользуются методы класса, 
   размер преаллоцированного участка указывается в [fft.hpp](./include/fft.hpp) ``PREALLOC_SIZE`` 

- в класс FFT добавлен подкласс thread_queue<num_threads> который является простым специализированным пулом потоков. Потоки выделяются заранее и ожидают команды для вычисления dft по строкам матриц. Количество задается как аргумент шаблона, задан в [fft.hpp](./include/fft.hpp) ``NUM_DFT_THREADS``
- выбор имплементации метода расчета строк матриц (std::async или thread pool) задаётся в [fft.hpp](./include/fft.hpp) как <br/>``ARRAY_DFT_METHOD = ARRAY_DFT_ASYNC | ARRAY_DFT_THREADS``
- Проведены замеры скорости работы алгоритмов

# Замеры скорости

были проведены замеры скорости для различных методов преобразования Фурье и различной длины преобразования. Также для различных их реализаций  
Все замеры делались 50 раз и бралось среднее  
Время обратных преобразований примерно равно прямым  

### N = 3 * 5 * 7 * 13 = 1365
| время(мс)/метод | dft error | fft_subdivide(13) error | fft error |
|--------|-----------------------|-------------------------|------------------------|
 std::async | 47.8 | 68.8 | 7.1
1 поток | 52.2 | 7.6 | 1.1 |
thread pool 4 потока | 47.7 | 7.5 | 1.3 |

### N = 3 * 4 * 5 * 7 * 13 = 5460
| время(мс)/метод | dft error | fft_subdivide(13) error | fft error |
|--------|-----------------------|-------------------------|------------------------|
std::async | 839 | 109.5 | 87
1 поток | 777 | 87.2 | 8.4 |
thread pool 4 потока | 728 | 82.6 | 7.6 |

### N = 2203 - простое число
| время(мс)/метод | dft error | fft_subdivide(1) error | fft error |
|--------|-----------------------|-------------------------|------------------------|
std::async | 115 | 158.6 | 113.1
1 поток | 118.3 | 160.3 | 111.8 |
thread pool 4 потока | 115 | 140 | 113.7 |

Немного выводов  
С тем как std::async задействован в данном проекте, он только замедляет работу  
Пул потоков независимо от количества выделеных потоков справляется либо также, либо немного хуже чем 1 поток  
Это может быть связано с работой примитивов синхронизации, передачей аргументов потокам, с тем что на каждый поток поступают относительно простые задачи 
