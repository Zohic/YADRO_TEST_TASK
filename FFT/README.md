- [Задание](#Задание)
- [Теория](#Теория)
- [Техническое решение](#Технические-решения)
- [USER API](#USER-API)
 ____
 
 # Задание
- Написать на С++ класс быстрого прямого и обратного преобразования Фурье комплексных значений с возможной длиной преобразования кратной 2, 3, 5.
- Запустить для случайных комплексных входных данных сначала прямое, а потом обратное преобразование Фурье.
- Сравнить ошибку между входными и выходными данными.
____
 # Теория
 ### В данном репозитории реализовано
 - Дискретное преобразование Фурье - прямое и обратное
 - Дискретное преобразование Фурье с разделением на множители
   <br/>
При разделении преобразование фурье с длиной преобразования $N$ на две части $N = N_1 * N_2$ асимптотическая сложность уменьшается с $O(N^2)$ до $O(N_1N_2)$
 <p align="center"> пример для $N = 1000$ при разбиении $N_1 = 20, N_2 = 50$ </p>
 <p align="center"> $N^2=10e6$ и $20*50=1000$ (разница в три порядка) </p>
 <br/>

 - Дискретное преобразование Фурье с рекурсивным разделением на множители (Вариант алгоритма Кули-Тьюки)
<br/>
   Длина преобразования рекурсивно разбивается на подмножители. Каждое разбиние уменьшает количество необходимых инструкций в итоге
   
   ___
# Технические решения
- Реализован класс __FFT__ в пространстве имён __YADRO_TEST__
- Все методы класса статические, вместо реализация шаблона singleton
- В отдельном заголовчном файле устанавливается флаг определяющий точность чисел используемых в проекте (float | double)
- Так как для реализуемых преобразований Фурье необходимы проходы по строкам/столбцам матриц, вместо использования матриц в пространстве имён __YADRO_TEST__ реализован класс __matrix_vector_mapper__ позволяющий проходить по линейным массивам как по строкам/столбцам матрицы
- методы класса __FFT__ являются шаблонами принимающими enum __dft_direction__, который определяет необходимое преобразование (прямое/обратное)
- В во всех методах с разделением на множители используется метод __dft_mapped__ преобразующий строки/столбцы матрицы. Каждое преобразование строки/столбца выполняется ассинхронно с помощью __std::async__ и __std::future__, что может ускорить работу (__std::async__ не всегда выполняет работу в отдельном потоке)

# USER API

```
//Делает простое прямое/обратное дискретное преобразование Фурье
FFT::dft<dft_direction>(const std::vector<complex_t> poinst, std::vector<complex_t>& spectrum)
```

```
//Делает дискретное преобразование фурье с разбиением на множители один из которых N1  
//Бросит исключение, если длина преобразования не делится на N1
FFT::fft_subdivided<dft_direction>(const std::vector<complex_t> poinst, std::vector<complex_t>& spectrum, size_t N1)
```

```
//Делает рекурсивное разбиение на простые множители (2, 3, 5, 7) и множители-степени двойки (16, 32, 64)
FFT::fft_recursive<dft_direction>(const std::vector<complex_t> poinst, std::vector<complex_t>& spectrum, size_t N1)
```
